#include "IR.h"	

/*******************************************************************************
* 函数名         : DelayMs()
* 函数功能		   : 延时
* 输入           : x
* 输出         	 : 无
*******************************************************************************/
 
unsigned char IrValue[6];	  //用来存放读取到的红外值
unsigned char IR_EVENT=0;
unsigned char IR_Value_Temp=0;

void Delay1ms()		//1ms延迟
{
	unsigned char i, j;

	i = 2;
	j = 239;
	do
	{
		while (--j);
	} while (--i);
}


void Delay140us()		//0.14ms时间延迟；0.56ms时间内采集3-4次，准确判断逻辑1或者0
{
	unsigned char i;

	_nop_();
	i = 67;
	while (--i);
}


/*******************************************************************************
* 函数名         : IrInit()
* 函数功能		   : 初始化红外线接收
* 输入           : 无
* 输出         	 : 无
*******************************************************************************/

void IrInit()    //端口INT0被占用，只能使用T2EX引脚，注意中断号是5，关闭中断有
	               //两个开关ET2和EXEN2,自动重装模式和波特率发生器模式均可；
{
 ET2=1;    //定时器2中断使能
 EXEN2=1;  //允许外部中断；
 //RCLK=1;   //输入波特率设置
 PT2=1;    //设置优先级，要求红外优先级相对比较高；
 TF2=0;
 TH2=0;      
 TL2=0;
 RCAP2L = 0;
 RCAP2H = 0;
 //TR2=1;	    //启用定时器
 EA=1;	//打开总中断
 IRIN=1;//初始化端口，准双向，先设置1，利于正确读取IR输入状态；
}
/*******************************************************************************
* 函数名         : ReadIr()
* 函数功能		   : 读取红外数值的中断函数
* 输入           : 无
* 输出         	 : 无
*******************************************************************************/


void ReadIr() interrupt 5  
{
	unsigned char j,k,Positive_Time;
	unsigned int err;
	Positive_Time=0;
	
	TF2=0;                     //清零中断标致;   
	EXF2=0;                    //清零中断标致；
	EXEN2=0;                   //关闭中断
	ET2=0;                     //关闭中断
	
  Delay1ms();               //延迟1ms排除干扰；	

	//first step，确认头码正确性；头码正确再继续解码；

	if(IRIN==0)		//确认是否真的接收到正确的信号
	{	
    err=100;		
		while((IRIN==0)&&(err>0))    //等待8ms低电平，超时退出
		 {
			err--;
			Delay140us();
		 }
		if(err==0)                 
		 {
			EXEN2=1;
			ET2=1;
		//printf("低电平超时退出\r\n");	
			return;			 
		 }
		 
		err=50;
		while((IRIN==1)&&(err>0))    //等4.5ms高电平，超时退出
		 {
			err--;
			Delay140us();
		 }
    if(err>=30||err==0)          //高电平时间过短2.5ms，认为是重复码，退出；
		 {
			EXEN2=1;
			ET2=1;	
		//	printf("重复码或者超时退出\r\n");		
			return;			 
		 }			 
	  
	  //printf("接收到正确头码\r\n");		//调试头码使用，头码正确后，必须注释掉，否则因为发送信息而造成延迟而错过头码后的波形
		                                  //并影响按键正确解码；
		 
	  //NEC码值，包括16位的客户码（8位原码和反码），和一个8位的遥控码和遥控反码；LSB先发；
			for(k=0;k<4;k++)		           //共有4组数据
			{				
				for(j=0;j<8;j++)	           //接收一组数据
				{
					while(!IRIN);              //等待信号前面的560us低电平过去
	        err=20;
					while((IRIN==1)&&(err>0))	 //计算高电平的时间长度，逻辑1。
					{
						Delay140us();	           //0.14ms
						Positive_Time++;
						err--;						
					}
					if(err==0)                 //逻辑1超时退出；
						{
							EXEN2=1;
							ET2=1;
							return;
						}
					IrValue[k]>>=1;	          //右移一位，高位补零，默认判定逻辑0，若大于0.56ms，是逻辑1，则置1操作；
					if(Positive_Time>=8)			
					{
						IrValue[k]|=0x80;
					}
					Positive_Time=0;		      //用完时间要重新赋值							
				}
			}			
		  IR_EVENT=1;	                  //接收完成，给IR事件置1，并且给缓冲赋IR遥控键值；
			IR_Value_Temp=IrValue[2];
		}	
	
	EXEN2=1;
  ET2=1;	
	return;
}	
